# 2025 暑 TYOI 集训小记

## Day 0 2025-08-03 星期日

- [x] 写游记

下午 15:20 的样子到的站，结果 16:00 才上地铁（？

不是我不理解，在车上看着只是乌云，怎么一出地铁就下辣么大的雨呢 $(⊙﹏⊙)$，重点是我装蚊帐的袋子还坏掉了 $(╯▔皿▔)╯$！！！

晚上好煎熬，有好多 dalao 切了第二天的题目 %%%

回寝直接洗洗睡了，还有两个 TY 本校的。

??? warning "后记，别看"
    为什么感觉学长的声音完全和长相不匹配啊啊啊啊啊啊

    ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ ＞﹏＜ 

## Day 1 2025-08-04 星期一


单调队列、树状数组、倍增、并查集

很正常，但是当你注意到 1 蓝 16 紫 的时候，事情就不简单了。

哦，12 点了，我先吃个午饭。

啊木啊木啊木拌面真豪赤
难怪我小学托管班老师是广东的，味道一模一样
啊木啊木啊木啊木啊木啊木啊木

不对，粉丝先吃（我没图）

老师讲是讲了，但是听不懂听不懂听不懂

困困困困困困困困困困困困

王超吧今天晚上体育课整辣么大强度的体能训练，真的是疯了

??? abstract "后记"
    ???+ info "08/05"
        蛙趣，昨天体锻后没有拉伸（老师没带我们做拉伸），早上起来血量上限减半，速度减半
    ???+ info "08/06"
        就算昨晚拉伸了，但是也不舒服，感觉速度又被削了，还带上了长达 29h 时长的剧毒效果。现在感觉腿是痛的。

先挂个袜子（洗了），后天再取

等会我先去食堂整点夜宵吃

啊木啊木啊木啊木

啊就像 [这样](https://www.bilibili.com/video/BV1NajgzFE9b/)。

牛肉丸真豪赤

## Day 2 2025-08-05 星期二

- [x] 写游记

先给出当天练题的题单。

[上午](https://www.luogu.com.cn/training/824074)

中午：哎不是怎么去晚了一丢丢就没拌面吃了 qwp

[下午](https://www.luogu.com.cn/training/822377)

什么是平衡树啊听不懂听不懂听不懂

什么是吉老师线段树啊听不懂听不懂听不懂

byd 第二天就往题单里塞黑题，还让不让人活了 (っ °Д °;)っ

感觉今天就在：

```cpp
while(1) {
    look("洛谷上的帖子");
    write("回复")；
}
```

还在 gza 的帖子里[开火](https://www.luogu.com.cn/discuss/1123895?page=28)了，[住了管理员楼下](https://www.luogu.com.cn/discuss/1123895?page=20)

哦对了因为 [CZOI](https://www.luogu.com.cn/contest/250226) 说有~~奶龙~~ **小游题**，我去看了一眼，没切。

今晚体育课前半截搁哪跳舞，nmd 这下真成小舞萌了，c。

??? note "哦对了"

    我们跳操的时候，跳了：
    - ~~奶龙~~ **小游** 舞

    音乐中包含了：
    - 江南 Style

    还有一些不记得，啊反正只要知道成分是十分复杂的就行。

## Day 3 2025-08-06 星期三

- [x] 写游记

事不过三······对吧？

![](https://cdn.luogu.com.cn/upload/image_hosting/qfi6nvlk.png)

[题单](https://www.luogu.com.cn/training/822388)中有一道绿题。

$$
\Huge{\text{但是对个鬼啊！！！}}
$$

那道绿题，是

$$
\Huge{\text{CDQ \ 分治}}
$$

我玩 nm，wdnmd！c，不玩了。

回到出题组，配数据去了。配了一下午 + 一晚上，一道垃圾小题目由于我不想写高精终于被我配好了（赛题暂不公开）

哦对了，晚上有体育课，这次晚上老师让我们打八段锦（？  
呆在那里，像极了体育馆里在某一种盛大的宗教盛会（？  
重点是，打完太极之后又化身小舞萌（？？？  
然后，由于我们是 B 班，然后又去打跆拳道（？？？？？

??? tips "tips"

    打跆拳道是从周一晚上开始的，虽然正常，但是成分复杂。

嗯，好一个综合全面发展！

## Day 4 2025-08-07 星期四

- [x] 写游记

莫队是干什么用的 awa？

怎么就这么写出来了 awa？

为什么要分块 awa？

等会分块是什么 awa？

[A Few Moments Later...](https://www.bilibili.com/video/BV15T41157Xg)

诶什么，二分？那不有手就行！

wc 这像是二分吗？

补兑，整体二分，整体二分是啥？

哦就是一起二分搜了。

那怎么搜呢 awa

wdnmd 我听不懂啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊！！！！！！！！！！！！！！！！！！！！！！！

[我想干但没干成的事情](https://www.bilibili.com/video/BV1F3ZFYUEMv)

## Day 5 2025-08-08 星期五

- [x] 写游记

平衡树听起来是十分舒服的✌

（大概原因是换了个学长讲课吧，hhh

今天还抢了个首解（[【模版】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)）

然后把它一起整合成了数据结构，想看我的 std 的自己看，不想看的略过谢谢。

??? danger "这几天的数据结构（不建议展开）"
    ```cpp
    /*
    * @file std-datastruct.cpp
    * @author Federico Prask
    * @time 2025-08-08
    */

    #include <bits/stdc++.h>
    #define file(s) \
        std::freopen(#s".in", "r", stdin), std::freopen(#s".out", "w", stdout)

    using i64 = long long;
    using ull = unsigned long long;
    using f32 = double;
    using ldb = long double;

    namespace trix{
        inline int readint() {
            register int x = 0, sign = 1;
            register char ch = getchar();
            for (; !isdigit(ch); ch = getchar()) {
                if (ch == '-') {    
                    sign = -1;
                }
                if (ch == EOF) {
                    return EOF;
                }
            }
            for (; isdigit(ch); ch = getchar()) {
                x = x * 10 + ch - '0';
            }
            return x * sign;
        }
        inline i64 readi64() {
            register i64 x = 0, sign = 1;
            register char ch = getchar();
            for (; !isdigit(ch); ch = getchar()) {
                if (ch == '-') {    
                    sign = -1;
                }
                if (ch == EOF) {
                    return EOF;
                }
            }
            for (; isdigit(ch); ch = getchar()) {
                x = x * 10 + ch - '0';
            }
            return x * sign;
        }
        inline char readchar() {
            register char ch = getchar();
            for (; ch == ' ' || ch == '\n'; ch = getchar()) {
                continue;
            }
            return ch;
        }
    }

    namespace DataStruct {
        // Segment-Tree
        template<int _N>
        class Segment_Tree_Segadd {
            struct binary_tree {
                i64 left_son = 0, right_son = 0;
                i64 value = 0, addition = 0;
            } node[_N << 2];
            i64 *a;
            
            public:
                void build_tree(i64 n, i64 *_a) {
                    a = _a;
                    _build_tree(1, 1, n);
                }
                void update(i64 l, i64 r, i64 val) {
                    if (l > r) return;
                    _update(1, l, r, val);
                }
                i64 query(i64 l, i64 r) {
                    if (l > r) return 0;
                    return _query(1, l, r);
                }
                
            private:
                void pushup(i64 x) {
                    node[x].value = node[x << 1].value + node[(x << 1) | 1].value;
                }
                void pushdown(i64 x) {
                    if (node[x].addition) {
                        i64 left = x << 1;
                        i64 right = (x << 1) | 1;
                        i64 len_left = node[left].right_son - node[left].left_son + 1;
                        i64 len_right = node[right].right_son - node[right].left_son + 1;
                        
                        node[left].addition += node[x].addition;
                        node[right].addition += node[x].addition;
                        node[left].value += node[x].addition * len_left;
                        node[right].value += node[x].addition * len_right;
                        node[x].addition = 0;
                    }
                }
                void _build_tree(i64 x, i64 l, i64 r) {
                    node[x].left_son = l;
                    node[x].right_son = r;
                    node[x].addition = 0;
                    if (l == r) {
                        node[x].value = a[l];
                        return;
                    }
                    i64 mid = (l + r) >> 1;
                    _build_tree(x << 1, l, mid);
                    _build_tree((x << 1) | 1, mid + 1, r);
                    pushup(x);
                }
                void _update(i64 now, i64 l, i64 r, i64 k) {
                    if (l <= node[now].left_son && r >= node[now].right_son) {
                        node[now].value += k * (node[now].right_son - node[now].left_son + 1);
                        node[now].addition += k;
                        return;
                    }
                    
                    pushdown(now);
                    i64 mid = (node[now].left_son + node[now].right_son) >> 1;
                    if (l <= mid) _update(now << 1, l, r, k);
                    if (r > mid) _update((now << 1) | 1, l, r, k);
                    pushup(now);
                }
                i64 _query(i64 x, i64 l, i64 r) {
                    if (l <= node[x].left_son && node[x].right_son <= r) {
                        return node[x].value;
                    }
                    pushdown(x);
                    i64 mid = (node[x].left_son + node[x].right_son) >> 1;
                    i64 sum = 0;
                    if (l <= mid) {
                        sum += _query(x << 1, l, r);
                    }
                    if (r > mid) {
                        sum += _query((x << 1) | 1, l, r);
                    }
                    return sum;
                }
            };

        // Segment-Tree for Range Cover (with Range Query)
        template<int _N>
        class Segment_Tree_Segcover {
            struct binary_tree {
                i64 left_son = 0, right_son = 0;
                i64 value = 0, cover = 0;
                bool has_cover = false;
            } node[_N << 2];
            i64 *a;
            
            public:
                void build_tree(i64 n, i64 *_a) {
                    a = _a;
                    _build_tree(1, 1, n);
                }
                void update(i64 l, i64 r, i64 val) {
                    if (l > r) return;
                    _update(1, l, r, val);
                }
                i64 query(i64 l, i64 r) {
                    if (l > r) return 0;
                    return _query(1, l, r);
                }
                
            private:
                void pushup(i64 x) {
                    node[x].value = node[x << 1].value + node[(x << 1) | 1].value;
                }
                void pushdown(i64 x) {
                    if (node[x].has_cover) {
                        i64 left = x << 1;
                        i64 right = (x << 1) | 1;
                        i64 len_left = node[left].right_son - node[left].left_son + 1;
                        i64 len_right = node[right].right_son - node[right].left_son + 1;
                        
                        node[left].cover = node[x].cover;
                        node[right].cover = node[x].cover;
                        node[left].value = node[x].cover * len_left;
                        node[right].value = node[x].cover * len_right;
                        node[left].has_cover = true;
                        node[right].has_cover = true;
                        
                        node[x].has_cover = false;
                    }
                }
                void _build_tree(i64 x, i64 l, i64 r) {
                    node[x].left_son = l;
                    node[x].right_son = r;
                    node[x].has_cover = false;
                    if (l == r) {
                        node[x].value = a[l];
                        return;
                    }
                    i64 mid = (l + r) >> 1;
                    _build_tree(x << 1, l, mid);
                    _build_tree((x << 1) | 1, mid + 1, r);
                    pushup(x);
                }
                void _update(i64 now, i64 l, i64 r, i64 k) {
                    if (l <= node[now].left_son && r >= node[now].right_son) {
                        node[now].value = k * (node[now].right_son - node[now].left_son + 1);
                        node[now].cover = k;
                        node[now].has_cover = true;
                        return;
                    }
                    
                    pushdown(now);
                    i64 mid = (node[now].left_son + node[now].right_son) >> 1;
                    if (l <= mid) _update(now << 1, l, r, k);
                    if (r > mid) _update((now << 1) | 1, l, r, k);
                    pushup(now);
                }
                i64 _query(i64 x, i64 l, i64 r) {
                    if (l <= node[x].left_son && node[x].right_son <= r) {
                        return node[x].value;
                    }
                    pushdown(x);
                    i64 mid = (node[x].left_son + node[x].right_son) >> 1;
                    i64 sum = 0;
                    if (l <= mid) {
                        sum += _query(x << 1, l, r);
                    }
                    if (r > mid) {
                        sum += _query((x << 1) | 1, l, r);
                    }
                    return sum;
                }
        };
        
        // Treap
        class Treap {
            // define a binary tree using arrays
            static const int MN = 2100005;
            int l[MN], r[MN];
            int value[MN], rand_val[MN], sz[MN], w[MN];
            int nans, size;
            int root;

            public:
                Treap() : root(0), size(0), nans(0) {
                    std::memset(l, 0, sizeof(l));
                    std::memset(r, 0, sizeof(r));
                    std::srand(std::time(0));
                }
                int qrnk(int x) {
                    return queryrank(root, x);
                }
                int qnum(int x) {
                    return querynum(root, x);
                }
                int qpre(int x) {
                    nans = 0;
                    querypre(root, x);
                    return nans ? value[nans] : -2147483647;
                }
                int qsub(int x) {
                    nans = 0;
                    querysub(root, x);
                    return nans ? value[nans] : 2147483647;
                }
                void del(int x) {
                    _delete(root, x);
                }
                void ins(int x) {
                    _insert(root, x);
                }

            private:
                void pushup(int x) {
                    sz[x] = sz[l[x]] + sz[r[x]] + w[x];
                }
                void left_rotate(int &k) {
                    int t = r[k];
                    r[k] = l[t];
                    l[t] = k;
                    sz[t] = sz[k];
                    pushup(k);
                    k = t;
                }
                void right_rotate(int &k) {
                    int t = l[k];
                    l[k] = r[t];
                    r[t] = k;
                    sz[t] = sz[k];
                    pushup(k);
                    k = t;
                }
                void _insert(int &k, int x) {
                    if (!k) {
                        size++;
                        k = size;
                        sz[k] = 1;
                        w[k] = 1;
                        value[k] = x;
                        rand_val[k] = rand();
                        return;
                    }
                    sz[k]++;
                    if (value[k] == x) {
                        w[k]++;
                    } else if (value[k] < x) {
                        _insert(r[k], x);
                        if (rand_val[r[k]] < rand_val[k]) {
                            left_rotate(k);
                        }
                    } else {
                        _insert(l[k], x);
                        if (rand_val[l[k]] < rand_val[k]) {
                            right_rotate(k);
                        }
                    }
                }
                bool _delete(int &k, int x) {
                    if (!k) {
                        return false;
                    }
                    if (value[k] == x) {
                        if (w[k] > 1) {
                            w[k]--;
                            sz[k]--;
                            return true;
                        }
                        if (l[k] == 0 || r[k] == 0) {
                            k = l[k] + r[k];
                            return true;
                        } else if (rand_val[l[k]] < rand_val[r[k]]) {
                            right_rotate(k);
                            return _delete(k, x);
                        } else {
                            left_rotate(k);
                            return _delete(k, x);
                        }
                    } else if (value[k] < x) {
                        bool succ = _delete(r[k], x);
                        if (succ) {
                            sz[k]--;
                        }
                        return succ;
                    } else {
                        bool succ = _delete(l[k], x);
                        if (succ) {
                            sz[k]--;
                        }
                        return succ;
                    }
                }
                int queryrank(int k, int x) {
                    if (!k) {
                        return 1;  // Return 1 if empty
                    }
                    if (value[k] == x) {
                        return sz[l[k]] + 1;
                    } else if (x > value[k]) {
                        return sz[l[k]] + w[k] + queryrank(r[k], x);
                    } else {
                        return queryrank(l[k], x);
                    }
                }
                int querynum(int k, int x) {
                    if (!k) {
                        return 0;
                    }
                    if (x <= sz[l[k]]) {
                        return querynum(l[k], x);
                    }
                    else if (x > sz[l[k]] + w[k]) {
                        return querynum(r[k], x - sz[l[k]] - w[k]);
                    }
                    else {
                        return value[k];
                    }
                }
                void querypre(int k, int x) {
                    if (!k) {
                        return;
                    }
                    if (value[k] < x) {
                        nans = k;
                        querypre(r[k], x);
                    }
                    else {
                        querypre(l[k], x);
                    }
                }
                void querysub(int k, int x) {
                    if (!k) {
                        return;
                    }
                    if (value[k] > x) {
                        nans = k;
                        querysub(l[k], x);
                    }
                    else {
                        querysub(r[k], x);
                    }
                }
        };

        // FHQ-Treap (Non-rotating Treap)
        class FHQTreap {
            static const int MN = 2100005;
            int l[MN], r[MN];
            int value[MN], rand_val[MN], sz[MN];
            int cnt, root;

            public:
                FHQTreap() : root(0), cnt(0) {
                    std::memset(l, 0, sizeof(l));
                    std::memset(r, 0, sizeof(r));
                    std::srand(std::time(0));
                }
                void ins(int x) {
                    int a, b;
                    split(root, x, a, b);
                    root = merge(merge(a, new_node(x)), b);
                }
                void del(int x) {
                    int a, b, c;
                    split(root, x, a, b);
                    split(b, x + 1, b, c);
                    if (b) {
                        b = merge(l[b], r[b]);
                    }
                    root = merge(merge(a, b), c);
                }
                int qrnk(int x) {
                    int a, b;
                    split(root, x - 1, a, b);
                    int res = sz[a] + 1;
                    root = merge(a, b);
                    return res;
                }
                int qnum(int k) {
                    return kth(root, k);
                }
                int qpre(int x) {
                    int a, b;
                    split(root, x - 1, a, b);
                    int res = kth(a, sz[a]);
                    root = merge(a, b);
                    return res;
                }
                int qsub(int x) {
                    int a, b;
                    split(root, x, a, b);
                    int res = kth(b, 1);
                    root = merge(a, b);
                    return res;
                }

            private:
                int new_node(int x) {
                    cnt++;
                    value[cnt] = x;
                    rand_val[cnt] = rand();
                    sz[cnt] = 1;
                    return cnt;
                }
                void pushup(int x) {
                    sz[x] = sz[l[x]] + sz[r[x]] + 1;
                }
                void split(int now, int k, int &x, int &y) {
                    if (!now) {
                        x = y = 0;
                        return;
                    }
                    if (value[now] <= k) {
                        x = now;
                        split(r[now], k, r[now], y);
                    } else {
                        y = now;
                        split(l[now], k, x, l[now]);
                    }
                    pushup(now);
                }
                int merge(int x, int y) {
                    if (!x || !y) {
                        return x | y;
                    }
                    if (rand_val[x] < rand_val[y]) {
                        r[x] = merge(r[x], y);
                        pushup(x);
                        return x;
                    } else {
                        l[y] = merge(x, l[y]);
                        pushup(y);
                        return y;
                    }
                }
                int kth(int now, int k) {
                    while (true) {
                        if (k <= sz[l[now]]) {
                            now = l[now];
                        } else if (k == sz[l[now]] + 1) {
                            return value[now];
                        } else {
                            k -= sz[l[now]] + 1;
                            now = r[now];
                        }
                    }
                }
        };

        // Persistent FHQ-Treap (Non-rotating Treap)
        class PersistentFHQTreap {
            static const int MN = 5e5 + 10;
            static const int INF = 2147483647;
            struct Node {
                int l, r;
                int val, key;
                int size;
            } t[MN * 50];

            public:
                int root[MN], cnt;
                PersistentFHQTreap() : cnt(0) {
                    std::fill(root, root + MN, 0);
                    std::srand(std::time(0));
                }
                void insert(int ver, int new_ver, int val) {
                    root[new_ver] = root[ver];
                    int x, y;
                    split(root[new_ver], val, x, y);
                    root[new_ver] = merge(merge(x, new_node(val)), y);
                }
                void remove(int ver, int new_ver, int val) {
                    root[new_ver] = root[ver];
                    int x, y, z;
                    split(root[new_ver], val, x, z);
                    split(x, val - 1, x, y);
                    if (y) y = merge(t[y].l, t[y].r);
                    root[new_ver] = merge(merge(x, y), z);
                }
                int get_rank(int ver, int val) {
                    int x, y;
                    split(root[ver], val - 1, x, y);
                    int res = t[x].size + 1;
                    root[ver] = merge(x, y);
                    return res;
                }
                int get_val(int ver, int rank) {
                    return _get_val(root[ver], rank);
                }
                int get_prev(int ver, int val) {
                    int x, y;
                    split(root[ver], val - 1, x, y);
                    if (!x) return -INF + 1;
                    int res = _get_val(x, t[x].size);
                    root[ver] = merge(x, y);
                    return res;
                }
                int get_next(int ver, int val) {
                    int x, y;
                    split(root[ver], val, x, y);
                    if (!y) return INF;
                    int res = _get_val(y, 1);
                    root[ver] = merge(x, y);
                    return res;
                }

            private:
                int new_node(int val) {
                    t[++cnt] = {0, 0, val, rand(), 1};
                    return cnt;
                }
                int clone(int p) {
                    if (!p) return 0;
                    t[++cnt] = t[p];
                    return cnt;
                }
                void pushup(int p) {
                    t[p].size = t[t[p].l].size + t[t[p].r].size + 1;
                }
                void split(int p, int val, int &x, int &y) {
                    if (!p) {
                        x = y = 0;
                        return;
                    }
                    p = clone(p);
                    if (t[p].val <= val) {
                        x = p;
                        split(t[x].r, val, t[x].r, y);
                    } else {
                        y = p;
                        split(t[y].l, val, x, t[y].l);
                    }
                    pushup(p);
                }
                int merge(int x, int y) {
                    if (!x || !y) return x | y;
                    if (t[x].key < t[y].key) {
                        x = clone(x);
                        t[x].r = merge(t[x].r, y);
                        pushup(x);
                        return x;
                    } else {
                        y = clone(y);
                        t[y].l = merge(x, t[y].l);
                        pushup(y);
                        return y;
                    }
                }
                int _get_val(int p, int rank) {
                    while (true) {
                        if (rank <= t[t[p].l].size) {
                            p = t[p].l;
                        } else if (rank == t[t[p].l].size + 1) {
                            return t[p].val;
                        } else {
                            rank -= t[t[p].l].size + 1;
                            p = t[p].r;
                        }
                    }
                }
        };
    }// namespace datastruct

    constexpr int M = 1e6;

    using trix::readint;

    int main() {
        #ifdef FILEIO
        file(std-datastruct);
        #endif

        #ifdef CPPIO
        std::cin.tie(0) -> sync_with_stdio(0);
        #endif

        /* Code Here. */

        return 0;
    }
    ```

哎不是，明天怎么还有测试啊，那我不炸了吗。

??? warning "别看"
    今天晚上跑步是跑了我们学校第一，但是吧，跑前多喝了点水，就在胃里摇啊摇啊摇，导致跑完之后有点难受  
    呕呕呕呕呕yueyueyueyueyue

    而且我们今天打跆拳道还不在馆内打，在室外。今天大太阳照了一天，晚上外面运动要热死了

对了，别问今天游记为什么这么短，因为我封装的数据结构太长了，也花费太多时间了，就没时间写了。

## Day 6 2025-08-09 星期六

- [x] 写游记

???+ tip "注意到"
    今天不考试了，延期了，今天做题，昨天的题抢到了 rank #2

晚上出去吃的，吃的什么瘦肉牛丸粿条，还不错，就是有点贵。

晚上买了杯瑞幸（不是广子也不是咖啡，点的奶茶），感觉还行，但是我很 unhappy 的一点就是我没有看到茶百道，不然我去点茶百道了。

今天过得一般般。

## Day 7 2025-08-10 星期日

- [ ] 写游记

今天去了一趟后面忘了。

???+ tip "看了一眼参观指南想起来了"
    今天去了一趟 $\Huge{广东科学中心}$。

    发现文创店里好多瑕疵品，所以没买。

    他的一些节气海报还挺好看的，具体详见我的微信朋友圈。

## Day 8 2025-08-11 星期一

- [ ] 写游记

忘记写了，忘了。

## Day 9 2025-08-12 星期二

- [ ] 写游记

忘记写了，基本忘了。

??? danger "千万"
    ??? danger "千万"
        ??? danger "要记住"
            ??? danger "打球"
                ??? danger "之前"
                    ??? danger "要看"
                        ??? danger "拍子的"
                            ??? danger "质量"
                                ??? danger "不然"
                                    ??? danger "你"
                                        ??? danger "可能会"
                                            ??? danger "遇到"
                                                ??? danger "挥拍"
                                                    ??? danger "之后"
                                                        ??? danger "拍子"
                                                            ??? danger "飞了"
                                                                ??? danger "十几米"
                                                                    ??? danger "远"
                                                                        ??? danger "然后"
                                                                            ??? danger "撞到"
                                                                                ??? danger "墙壁"
                                                                                    ??? danger "掉下了"
                                                                                        ??? danger "楼"
                                                                                            （虽然是 zqh 干的但我还是热心的提醒一下大家）

~~很好的嵌套使我的大脑旋转。~~

## Day 10 2025-08-13 星期三

- [x] 写游记

**上午**

睡觉，使得我的鼠标垫湿了（我出一身汗）

??? question "我不李姐"
    总是有一些时候睡觉出特别多的汗，但是晚上从来不出。

**下午**

很好的洛谷月赛，证明 T1 的正解的正确性使我的大脑翻转（本来准备今晚写的）。

**晚上**

听歌写游记。

体育课打乒乓发现地形崎岖，~~一看就是丘陵地形~~。


## Day 11 2025-08-14 星期四

- [ ] 写游记

## Day 12 2025-08-15 星期五

- [x] 写游记
- [x] 开发网站

网站做的不错

但是我是唐比，做网站的时候把我以前的项目删掉了（输入的命令清空了文件夹才配置的架构）

需要找个时间修一下。

[链接](https://lsoi.pages.dev)

晚自习稍微加了个新功能，也就是网站的“关于”部分。

之后会慢慢加功能的。

## Day 13 2025-08-16 星期六

- [x] 写游记

上午测了个试，运气好拿了个 rank #1

??? quote "总结（别看，反正就是我是人机）"
    重要的事情说三遍

    省流：我是人机，我太菜了，我是蒟蒻

    省流：我是人机，我太菜了，我是蒟蒻

    省流：我是人机，我太菜了，我是蒟蒻

    虽然，

    ![](https://cdn.luogu.com.cn/upload/image_hosting/fb8klhdq.png)

    但是你仔细看看，

    $\because$

    ![](https://cdn.luogu.com.cn/upload/image_hosting/6wx105dv.png)

    $\therefore$

    我今天下午上机，电脑炸了 5 次，有三次我强制重启了，剩下的两次我狂按 $\text{Alt + F4}$ 把窗口关掉了。

    > tips: 我猜这电脑有内存泄漏，而且虚拟内存剧小，使得我总是容易内存爆栈。

    ~~T1 没过~~，签到题没过说明我太菜了，没有写出正解，看来我的刷题量还是太少了 ![](https://cdn.luogu.com.cn/upload/image_hosting/xp7iboxe.png)。

    T2 正常解出来，显然切 T2 的人还是特别多的。

    T3 太惊险了，自己看提交时间吧。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/nv5dwkoy.png)

    显然，我还是太菜了，dp 学的不行，就是个废物。

    而且代码还有人认为是人机（AI）。

    不过确实，当时注意到容易炸（最开始写的用了四维数组，算了下内存占用，要 4 个 GB，所以后来用了 `vector`，使得我的代码非常抽象）

    （以后会改的）

    > ```cpp
    > std::vector<std::vector<std::vector<int>>> dp(
    >         a + 1, std::vector<std::vector<int>>(
    >             b + 1, std::vector<int>(c + 1, INF)));
    > ```

    （我也觉得挺狗屎，不过顺便给大家看我一位学长的逆天操作就会觉得这世间是有人上人的）

    （还是 Vim 大佬）

    > ![](https://cdn.luogu.com.cn/upload/image_hosting/l3h8016s.png)
    > ![](https://cdn.luogu.com.cn/upload/image_hosting/bebem32k.png)

    （事后他发现 `vector` 让他 TLE 了）

    做 T5 时很庆幸前一天晚上找我的学长复习了以下可持久化数据结构，所以今天~~打~~使用我之前的主席树板子还是挺顺畅的。

    T6 的淀粉质我不会，啊所以还是我太菜了，加上超长码量我肯定是想不出来的，（赛时也肯定写不出来）。

    不过写 T6 的时候时间不多了，所以我光速打了个暴搜跑路了（很好的拿下了 Subtask 1）

    显然我运气还是很好的，混了个 505 的 rank #1，~~没想到这么蒟蒻也配拿 rank #1~~。

    ~~咦原来橙漫山茶花就是直接把不去皮的橙子放进去吗~~

晚上和学长出去吃了个饭，~~还偷偷很同学打电话聊了会天~~。

哦对了，还打了会 Phi。

## Day 14 2025-08-17 星期日

- [x] 写游记

显然，我们四个拥有具有游戏属性的设备的人中，有三个都是玩三角洲的。

所以他们三个从早上吃完饭就开始赖着打三角洲。

上午的计划是去中山大学。

逛完博物馆吧，待在他的文创店，看到插头又是直接开玩，直接给干到了闭馆时间，工作人员要求我们 **~~滚~~** 离开。

下午待在寝室，同学发了道高中数学题过来，被我秒了。

（但是晚上听讲座没事干还是去写了一份详细证明）

哦晚上联合去打白复生 IN Lv.16 了，我们几个真厉害（一前面一结尾一旁观），打出了 10 G 的好成绩（原来没有 FC）。

## Day 15 2025-08-18 星期一

- [x] 写游记
- [x] 修复文档站

咦 @ImposterAnYu 晚上 0 点还在看洛谷啊？还有犇犇发，羡慕了。

今天为 [网站](https://lsoi.pages.dev) 增加了一点新功能，具体就是能够支持 Markdown 嵌入和 KaTeX 支持。

??? failure "失败"
    今天调试网站代码，由于 KaTeX 对于格式要求不一般的高，使得我调了半个小时才调好。

不过有了 Markdown 就方便了，今天把大家的个人主页做成了 Markdown 嵌入的，目前是直接抓取的洛谷上的源码。

哦对了，~~黄川铭~~ **安雨姐姐** 还告诉了我 [benben.sbs](https://benben.sbs) 的奇妙网址。
