## 思路与算法

### 题目大意

题目给定一个未完成的数独（用 `.` 表示空格），保证有唯一解，要求输出填完后的数独。

忘记数独规则的~~和不会玩数独的~~看过来：

数独需要玩家在一个 $9 \times 9$ 的网格中填入数字 $1 \sim 9$，使得：

1. **每一行**包含 $1 \sim 9$ 且不重复；
2. **每一列**包含 $1 \sim 9$ 且不重复；
3. **每一个 $3 \times 3$ 的格子**包含 $1 \sim 9$ 且不重复。

### 算法

~~注意到，算法标签说明这是一道 DFS 题，~~

这里我们可以使用 DFS 遍历并枚举每一个空格所填的数，并检查是否合法。

所以，这里我们用的算法就会是 DFS（深度优先搜索）啦，~~也就变成了一道橙题~~。

## 代码
### C/C++：
```c
#include <stdio.h>
#include <stdbool.h>

char board[9][9];
bool solved = false;

bool isValid(int row, int col, char num) {
    for (int i = 0; i < 9; i++) {
        if (board[row][i] == num) {
            return false;
        }
    }
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == num) {
            return false;
        }
    }
    int boxRow = row / 3 * 3;
    int boxCol = col / 3 * 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[boxRow + i][boxCol + j] == num) {
                return false;
            }
        }
    }
    return true;
}

void dfs(int row, int col) {
    if (row == 9) {
        solved = true;
        return;
    }
    if (col == 9) {
        dfs(row + 1, 0);
        return;
    }
    if (board[row][col] != '.') {
        dfs(row, col + 1);
        return;
    }
    for (char num = '1'; num <= '9'; num++) {
        if (isValid(row, col, num)) {
            board[row][col] = num;
            dfs(row, col + 1);
            if (solved) {
                return;
            }
            board[row][col] = '.';
        }
    }
}

int main() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            scanf("%c", &board[i][j]);
        }
        getchar(); // 吃换行
    }
    dfs(0, 0);
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            printf("%c", board[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```
[其他语言（C#，Java，Python）](https://www.luogu.com.cn/paste/seqtaqvk)